# 进程和线程
___

### 1. 多进程

   * 概念

          通过fork()调用，fork()调用一次，返回两次，因为操作系统自动把当前进程（称为父进程）复制了一份(称为子进程)，
          然后，分别在父进程和子进程内返回，子进程永远返回0，而父进程返回子进程的ID，一个父进程可以fork出很多子进程，
          所以，父进程要记下每个子进程的ID，而子进程只需要调用getppid()就可以拿到父进程的ID
  
  * 子进程
  
          subprocess 模块可以方便启动一个子进程，控制输入和输出
          
          如果子进程还需要输入，可以使用communitcate()
          
  * 进程间通信
  
          跨平台进程，可以使用multiprocessing模块，进程间相互通信通过queue,pipes等实现
          
### 2. 多线程
  
  * 概念
   
          一个进程有多个线程，线程运行依靠threading模块
          
  * 锁机制
  
          多线程运作中，所有变量都由所有线程共享，所以任何一个变量都可以被任何一个线程修改，如果一个线程崩溃，整个进程就会崩溃
          
          所以在执行代码时，有GIL锁，任何Python线程执行前，必须先获得GIL锁，然后每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行
          
          由于GIL锁，所以多线程无法利用多核，但是可以用多个进程，每个进程中的线程有各自独立的锁
          
### 3. ThreadLocal

          一个ThreadLocal变量虽然是全局变量，但每个线程都只能读写自己线程的独立副本，互不干扰。ThreadLocal解决了参数在一个线程中各个函数之间互相传递的问题
          ThreadLocal常用在为每个线程绑定一个数据库链接，http请求，用户身份信息等，这样一个线程的所有调用到的处理函数都可以非常方便地访问这些资源。
          
### 4. 进程 vs 线程

  * 多进程
       
           稳定性高，一个子进程崩溃不会影响主进程和其他子进程，但是构建进程代价大
  
  * 多线程
  
           多线程比多进程快一点，但如果其中一个线程挂掉，整个进程就会崩盘，因为所以线程共享进程内存
           
### 5. 异步IO

  * 协程
    
           在一个线程中，不存在锁机制，且子程序的切换不是线程的切换，而由程序自身控制，所以具有极高的执行效率；多核CPU下，多进程+协程效率爆棚
           
           python中对协程的支持是通过生成器(generator)，可以通过for循环来迭代，还可以不断调用next()函数获取由yield语句返回的下一个值
           
  * asyncio
  
           用来实现异步IO操作，yield from 具有中断功能，传出值，接收值，还省去了很多异常处理，并结合@asyncio coroutine 实现协程
           
           在python3.5版本之后，@asyncio coroutine 替换为 async, yield from 替换为 await
           
  * aiohttp
  
           aiohttp则是基于asyncio实现的HTTP框架，实现异步网页请求
           
       [利用aiohttp网页爬虫实例](https://blog.csdn.net/SL_World/article/details/86633611)
          
        
